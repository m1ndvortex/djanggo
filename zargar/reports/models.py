"""
Comprehensive reporting engine models for ZARGAR jewelry SaaS platform.

This module implements Persian financial reports, inventory valuation,
customer aging reports, and automated report scheduling with Persian
localization and Shamsi calendar support.
"""

from django.db import models
from django.utils.translation import gettext_lazy as _
from django.core.validators import MinValueValidator, MaxValueValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
from decimal import Decimal, ROUND_HALF_UP
from zargar.core.models import TenantAwareModel
import jdatetime
import json
from typing import Dict, List, Optional, Any


class ReportTemplate(TenantAwareModel):
    """
    Report template model for defining reusable report configurations.
    """
    
    REPORT_TYPES = [
        ('trial_balance', _('Trial Balance (ترازنامه آزمایشی)')),
        ('profit_loss', _('Profit & Loss Statement (سود و زیان)')),
        ('balance_sheet', _('Balance Sheet (ترازنامه)')),
        ('inventory_valuation', _('Inventory Valuation (ارزش‌گذاری موجودی)')),
        ('customer_aging', _('Customer Aging Report (تحلیل سن مطالبات)')),
        ('sales_summary', _('Sales Summary (خلاصه فروش)')),
        ('gold_price_analysis', _('Gold Price Analysis (تحلیل قیمت طلا)')),
        ('installment_summary', _('Installment Summary (خلاصه اقساط)')),
        ('custom', _('Custom Report (گزارش سفارشی)')),
    ]
    
    OUTPUT_FORMATS = [
        ('pdf', _('PDF')),
        ('excel', _('Excel')),
        ('csv', _('CSV')),
        ('json', _('JSON')),
    ]
    
    # Template identification
    name = models.CharField(
        max_length=200,
        verbose_name=_('Template Name')
    )
    name_persian = models.CharField(
        max_length=200,
        verbose_name=_('Persian Template Name')
    )
    description = models.TextField(
        blank=True,
        verbose_name=_('Description')
    )
    
    # Report configuration
    report_type = models.CharField(
        max_length=30,
        choices=REPORT_TYPES,
        verbose_name=_('Report Type')
    )
    default_output_format = models.CharField(
        max_length=10,
        choices=OUTPUT_FORMATS,
        default='pdf',
        verbose_name=_('Default Output Format')
    )
    
    # Template settings
    template_config = models.JSONField(
        default=dict,
        verbose_name=_('Template Configuration'),
        help_text=_('JSON configuration for report parameters')
    )
    
    # Display settings
    include_persian_headers = models.BooleanField(
        default=True,
        verbose_name=_('Include Persian Headers')
    )
    use_shamsi_dates = models.BooleanField(
        default=True,
        verbose_name=_('Use Shamsi Dates')
    )
    use_persian_numbers = models.BooleanField(
        default=True,
        verbose_name=_('Use Persian Numbers')
    )
    
    # Status
    is_active = models.BooleanField(
        default=True,
        verbose_name=_('Is Active')
    )
    is_system_template = models.BooleanField(
        default=False,
        verbose_name=_('Is System Template'),
        help_text=_('System templates cannot be deleted')
    )
    
    class Meta:
        verbose_name = _('Report Template')
        verbose_name_plural = _('Report Templates')
        ordering = ['report_type', 'name']
        indexes = [
            models.Index(fields=['report_type']),
            models.Index(fields=['is_active']),
        ]
    
    def __str__(self):
        return self.name_persian or self.name


class GeneratedReport(TenantAwareModel):
    """
    Generated report model for tracking report execution and storage.
    """
    
    STATUS_CHOICES = [
        ('pending', _('Pending')),
        ('generating', _('Generating')),
        ('completed', _('Completed')),
        ('failed', _('Failed')),
        ('expired', _('Expired')),
    ]
    
    # Report identification
    report_id = models.CharField(
        max_length=50,
        unique=True,
        verbose_name=_('Report ID')
    )
    template = models.ForeignKey(
        ReportTemplate,
        on_delete=models.PROTECT,
        related_name='generated_reports',
        verbose_name=_('Report Template')
    )
    
    # Generation details
    generated_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name=_('Generated At')
    )
    generated_by = models.ForeignKey(
        'core.User',
        on_delete=models.SET_NULL,
        null=True,
        related_name='generated_reports',
        verbose_name=_('Generated By')
    )
    
    # Report parameters
    report_parameters = models.JSONField(
        default=dict,
        verbose_name=_('Report Parameters'),
        help_text=_('Parameters used for report generation')
    )
    
    # Date range
    date_from = models.DateField(
        null=True,
        blank=True,
        verbose_name=_('Date From')
    )
    date_to = models.DateField(
        null=True,
        blank=True,
        verbose_name=_('Date To')
    )
    date_from_shamsi = models.CharField(
        max_length=10,
        blank=True,
        verbose_name=_('Date From (Shamsi)')
    )
    date_to_shamsi = models.CharField(
        max_length=10,
        blank=True,
        verbose_name=_('Date To (Shamsi)')
    )
    
    # Output details
    output_format = models.CharField(
        max_length=10,
        choices=ReportTemplate.OUTPUT_FORMATS,
        verbose_name=_('Output Format')
    )
    file_path = models.CharField(
        max_length=500,
        blank=True,
        verbose_name=_('File Path')
    )
    file_size_bytes = models.PositiveIntegerField(
        null=True,
        blank=True,
        verbose_name=_('File Size (Bytes)')
    )
    
    # Status and timing
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        verbose_name=_('Status')
    )
    generation_started_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Generation Started At')
    )
    generation_completed_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Generation Completed At')
    )
    generation_duration_seconds = models.PositiveIntegerField(
        null=True,
        blank=True,
        verbose_name=_('Generation Duration (Seconds)')
    )
    
    # Error handling
    error_message = models.TextField(
        blank=True,
        verbose_name=_('Error Message')
    )
    
    # Expiration
    expires_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Expires At')
    )
    
    # Report data (for JSON reports or caching)
    report_data = models.JSONField(
        null=True,
        blank=True,
        verbose_name=_('Report Data'),
        help_text=_('Cached report data for quick access')
    )
    
    class Meta:
        verbose_name = _('Generated Report')
        verbose_name_plural = _('Generated Reports')
        ordering = ['-generated_at']
        indexes = [
            models.Index(fields=['report_id']),
            models.Index(fields=['template']),
            models.Index(fields=['status']),
            models.Index(fields=['generated_at']),
            models.Index(fields=['expires_at']),
        ]
    
    def __str__(self):
        return f"{self.template.name} - {self.generated_at.strftime('%Y-%m-%d %H:%M')}"
    
    def save(self, *args, **kwargs):
        """Generate report ID and set Shamsi dates."""
        if not self.report_id:
            self.report_id = self.generate_report_id()
        
        # Set Shamsi dates
        if self.date_from and not self.date_from_shamsi:
            shamsi_date = jdatetime.date.fromgregorian(date=self.date_from)
            self.date_from_shamsi = shamsi_date.strftime('%Y/%m/%d')
        
        if self.date_to and not self.date_to_shamsi:
            shamsi_date = jdatetime.date.fromgregorian(date=self.date_to)
            self.date_to_shamsi = shamsi_date.strftime('%Y/%m/%d')
        
        # Set expiration (default 30 days)
        if not self.expires_at:
            self.expires_at = timezone.now() + timezone.timedelta(days=30)
        
        super().save(*args, **kwargs)
    
    def generate_report_id(self) -> str:
        """Generate unique report ID."""
        import uuid
        return f"RPT-{timezone.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}"
    
    @property
    def is_expired(self) -> bool:
        """Check if report has expired."""
        return self.expires_at and timezone.now() > self.expires_at
    
    @property
    def download_filename(self) -> str:
        """Generate download filename."""
        template_name = self.template.name.replace(' ', '_').lower()
        date_str = self.generated_at.strftime('%Y%m%d_%H%M')
        return f"{template_name}_{date_str}.{self.output_format}"


class ReportSchedule(TenantAwareModel):
    """
    Report scheduling model for automated report generation and delivery.
    """
    
    FREQUENCY_CHOICES = [
        ('daily', _('Daily')),
        ('weekly', _('Weekly')),
        ('monthly', _('Monthly')),
        ('quarterly', _('Quarterly')),
        ('yearly', _('Yearly')),
    ]
    
    DELIVERY_METHODS = [
        ('email', _('Email')),
        ('sms', _('SMS')),
        ('internal', _('Internal Dashboard')),
        ('file_storage', _('File Storage')),
    ]
    
    # Schedule identification
    name = models.CharField(
        max_length=200,
        verbose_name=_('Schedule Name')
    )
    name_persian = models.CharField(
        max_length=200,
        verbose_name=_('Persian Schedule Name')
    )
    description = models.TextField(
        blank=True,
        verbose_name=_('Description')
    )
    
    # Template and parameters
    template = models.ForeignKey(
        ReportTemplate,
        on_delete=models.CASCADE,
        related_name='schedules',
        verbose_name=_('Report Template')
    )
    schedule_parameters = models.JSONField(
        default=dict,
        verbose_name=_('Schedule Parameters')
    )
    
    # Scheduling
    frequency = models.CharField(
        max_length=20,
        choices=FREQUENCY_CHOICES,
        verbose_name=_('Frequency')
    )
    start_date = models.DateField(
        verbose_name=_('Start Date')
    )
    end_date = models.DateField(
        null=True,
        blank=True,
        verbose_name=_('End Date')
    )
    
    # Timing
    execution_time = models.TimeField(
        default='08:00:00',
        verbose_name=_('Execution Time'),
        help_text=_('Time of day to generate report')
    )
    
    # Weekly scheduling (for weekly frequency)
    day_of_week = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0), MaxValueValidator(6)],
        verbose_name=_('Day of Week'),
        help_text=_('0=Monday, 6=Sunday (for weekly reports)')
    )
    
    # Monthly scheduling (for monthly frequency)
    day_of_month = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(1), MaxValueValidator(31)],
        verbose_name=_('Day of Month'),
        help_text=_('Day of month to generate report (for monthly reports)')
    )
    
    # Delivery settings
    delivery_methods = models.JSONField(
        default=list,
        verbose_name=_('Delivery Methods'),
        help_text=_('List of delivery methods')
    )
    email_recipients = models.JSONField(
        default=list,
        verbose_name=_('Email Recipients'),
        help_text=_('List of email addresses for delivery')
    )
    sms_recipients = models.JSONField(
        default=list,
        verbose_name=_('SMS Recipients'),
        help_text=_('List of phone numbers for SMS delivery')
    )
    
    # Status
    is_active = models.BooleanField(
        default=True,
        verbose_name=_('Is Active')
    )
    last_execution = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Last Execution')
    )
    next_execution = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Next Execution')
    )
    
    # Statistics
    total_executions = models.PositiveIntegerField(
        default=0,
        verbose_name=_('Total Executions')
    )
    successful_executions = models.PositiveIntegerField(
        default=0,
        verbose_name=_('Successful Executions')
    )
    failed_executions = models.PositiveIntegerField(
        default=0,
        verbose_name=_('Failed Executions')
    )
    
    class Meta:
        verbose_name = _('Report Schedule')
        verbose_name_plural = _('Report Schedules')
        ordering = ['name']
        indexes = [
            models.Index(fields=['is_active']),
            models.Index(fields=['next_execution']),
            models.Index(fields=['frequency']),
        ]
    
    def __str__(self):
        return self.name_persian or self.name
    
    def save(self, *args, **kwargs):
        """Calculate next execution time."""
        if not self.next_execution and self.is_active:
            self.calculate_next_execution()
        
        super().save(*args, **kwargs)
    
    def calculate_next_execution(self):
        """Calculate next execution datetime."""
        from datetime import datetime, time, timedelta
        
        now = timezone.now()
        base_date = self.last_execution.date() if self.last_execution else self.start_date
        
        if self.frequency == 'daily':
            next_date = base_date + timedelta(days=1)
        elif self.frequency == 'weekly':
            days_ahead = self.day_of_week - base_date.weekday()
            if days_ahead <= 0:  # Target day already happened this week
                days_ahead += 7
            next_date = base_date + timedelta(days=days_ahead)
        elif self.frequency == 'monthly':
            # Calculate next month
            if base_date.month == 12:
                next_month = base_date.replace(year=base_date.year + 1, month=1)
            else:
                next_month = base_date.replace(month=base_date.month + 1)
            
            # Set day of month
            try:
                next_date = next_month.replace(day=self.day_of_month or 1)
            except ValueError:
                # Handle months with fewer days
                next_date = next_month.replace(day=28)
        elif self.frequency == 'quarterly':
            next_date = base_date + timedelta(days=90)  # Approximate
        elif self.frequency == 'yearly':
            next_date = base_date.replace(year=base_date.year + 1)
        else:
            next_date = base_date + timedelta(days=1)
        
        # Combine with execution time
        self.next_execution = timezone.make_aware(
            datetime.combine(next_date, self.execution_time)
        )
    
    def should_execute_now(self) -> bool:
        """Check if schedule should execute now."""
        if not self.is_active or not self.next_execution:
            return False
        
        now = timezone.now()
        return now >= self.next_execution
    
    def mark_execution(self, success: bool = True):
        """Mark schedule as executed."""
        self.last_execution = timezone.now()
        self.total_executions += 1
        
        if success:
            self.successful_executions += 1
        else:
            self.failed_executions += 1
        
        # Calculate next execution
        self.calculate_next_execution()
        
        self.save(update_fields=[
            'last_execution',
            'total_executions',
            'successful_executions',
            'failed_executions',
            'next_execution',
            'updated_at'
        ])


class ReportDelivery(TenantAwareModel):
    """
    Report delivery tracking model.
    """
    
    DELIVERY_STATUS_CHOICES = [
        ('pending', _('Pending')),
        ('sent', _('Sent')),
        ('delivered', _('Delivered')),
        ('failed', _('Failed')),
        ('bounced', _('Bounced')),
    ]
    
    # Delivery identification
    generated_report = models.ForeignKey(
        GeneratedReport,
        on_delete=models.CASCADE,
        related_name='deliveries',
        verbose_name=_('Generated Report')
    )
    schedule = models.ForeignKey(
        ReportSchedule,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='deliveries',
        verbose_name=_('Report Schedule')
    )
    
    # Delivery details
    delivery_method = models.CharField(
        max_length=20,
        choices=ReportSchedule.DELIVERY_METHODS,
        verbose_name=_('Delivery Method')
    )
    recipient = models.CharField(
        max_length=200,
        verbose_name=_('Recipient'),
        help_text=_('Email address or phone number')
    )
    
    # Status and timing
    status = models.CharField(
        max_length=20,
        choices=DELIVERY_STATUS_CHOICES,
        default='pending',
        verbose_name=_('Delivery Status')
    )
    sent_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Sent At')
    )
    delivered_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_('Delivered At')
    )
    
    # Error handling
    error_message = models.TextField(
        blank=True,
        verbose_name=_('Error Message')
    )
    retry_count = models.PositiveIntegerField(
        default=0,
        verbose_name=_('Retry Count')
    )
    max_retries = models.PositiveIntegerField(
        default=3,
        verbose_name=_('Max Retries')
    )
    
    # Delivery metadata
    delivery_metadata = models.JSONField(
        default=dict,
        verbose_name=_('Delivery Metadata'),
        help_text=_('Additional delivery information')
    )
    
    class Meta:
        verbose_name = _('Report Delivery')
        verbose_name_plural = _('Report Deliveries')
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['generated_report']),
            models.Index(fields=['status']),
            models.Index(fields=['delivery_method']),
        ]
    
    def __str__(self):
        return f"{self.generated_report.template.name} -> {self.recipient}"
    
    @property
    def can_retry(self) -> bool:
        """Check if delivery can be retried."""
        return (self.status == 'failed' and 
                self.retry_count < self.max_retries)
    
    def mark_sent(self):
        """Mark delivery as sent."""
        self.status = 'sent'
        self.sent_at = timezone.now()
        self.save(update_fields=['status', 'sent_at', 'updated_at'])
    
    def mark_delivered(self):
        """Mark delivery as delivered."""
        self.status = 'delivered'
        self.delivered_at = timezone.now()
        self.save(update_fields=['status', 'delivered_at', 'updated_at'])
    
    def mark_failed(self, error_message: str = ""):
        """Mark delivery as failed."""
        self.status = 'failed'
        self.error_message = error_message
        self.retry_count += 1
        self.save(update_fields=['status', 'error_message', 'retry_count', 'updated_at'])